---
title: Java学习笔记-3
date: 2018-08-30 13:20:55
tags: 
 - Java
 - Spring
categories: IT
---
# HTTP协议 POST和GET的区别

[浅谈HTTP中Get与Post的区别](http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html)

- Http定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而HTTP中的GET，POST，PUT，DELETE就对应着对这个资源的查，改，增，删4个操作。
- GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。

## 原理性的区别

### GET 安全与幂等
根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。

(1) 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。

(2) 幂等的意味着对同一URL的多个请求应该返回同样的结果。

但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。

### POST 可能修改服务器上的资源请求
- 继续引用上面的例子：还是新闻以网站为例，读者对新闻发表自己的评论应该通过POST实现，因为在评论提交后站点的资源已经不同了，或者说资源被修改了。

## 应用上的区别

**说完原理性的问题，我们再从表面现像上面看看GET和POST的区别：**

1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连，如：

> login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。

如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。

POST把提交的数据则放置在是HTTP包的包体中。

2."GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据。

3.在ASP中，服务端获取GET请求参数用Request.QueryString；获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\"XXXX\")来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个``test.jsp?name=hyddd&password=hyddd``，用request.getQueryString()得到的是：``name=hyddd&password=hyddd``。

4.POST的安全性要比GET的安全性高。

注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为：

(1)登录页面有可能被浏览器缓存；

(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了。

除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。

## 总结
总结一下，Get是**向服务器发索取数据的一种请求**，而Post是**向服务器提交数据的一种请求**，在FORM（表单）中，Method默认为"GET"，实质上，GET和POST只是发送机制不同，并不是一个取一个发。

# Java对象的生命周期

[Java 对象的生命周期](https://blog.csdn.net/moneyshi/article/details/53033578)

- 在Java中，对象的生命周期包括以下几个阶段：
1.  创建阶段(Created)

2.  应用阶段(In Use)

3.  不可见阶段(Invisible)

4.  不可达阶段(Unreachable)

5.  收集阶段(Collected)

6.  终结阶段(Finalized)

7.  对象空间重分配阶段(De-allocated)

![JavaObject Life Cycle](https://img-blog.csdn.net/20140805161851452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29kaW5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 创建阶段

在创建阶段系统通过下面的几个步骤来完成对象的创建过程

- 为对象分配存储空间
- 开始构造对象
- 从超类到子类对static成员进行初始化
- 超类成员变量按顺序初始化，递归调用超类的构造方法
- 子类成员变量按顺序初始化，子类构造方法调用

一旦对象被创建，并被分派给某些变量赋值，这个对象的状态就切换到了应用阶段

## 应用阶段

对象至少被一个强引用持有着。

## 不可见阶段

当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该这些引用仍然是存在着的。

简单说就是程序的执行已经超出了该对象的作用域了。

举例如下图：本地变量count在25行时已经超出了其作用域，则在此时称之为count处于不可视阶段。当然这种情况编译器在编译的过程中会直接报错了。

![不可见阶段示例](https://img-blog.csdn.net/20140805162025676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc29kaW5v/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

## 不可达阶段

对象处于不可达阶段是指该对象不再被任何强引用所持有。

与“不可见阶段”相比，“不可见阶段”是指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或JNI等强引用持有着，这些特殊的强引用被称为”GC root”。存在着这些GC root会导致对象的内存泄露情况，无法被回收。

## 收集阶段

当垃圾回收器发现该对象已经处于“不可达阶段”并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了“收集阶段”。如果该对象已经重写了finalize()方法，则会去执行该方法的终端操作。

这里要特别说明一下：不要重载finazlie()方法！原因有两点：

- 会影响JVM的对象分配与回收速度

在分配该对象时，JVM需要在垃圾回收器上注册该对象，以便在回收时能够执行该重载方法；在该方法的执行时需要消耗CPU时间且在执行完该方法后才会重新执行回收操作，即至少需要垃圾回收器对该对象执行两次GC。

- 可能造成该对象的再次“复活”

在finalize()方法中，如果有其它的强引用再次持有该对象，则会导致对象的状态由“收集阶段”又重新变为“应用阶段”。这个已经破坏了Java对象的生命周期进程，且“复活”的对象不利用后续的代码管理。

## 终结阶段

当对象执行完finalize()方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。

## 对象空间重新分配阶段

垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为“对象空间重新分配阶段”。

# 重载、重写以及继承、多态的区别

[重载、重写以及继承、多态的区别](https://www.cnblogs.com/cugwx/p/3650605.html)

## 继承(inheritance) 

- 简单的说，继承就是在一个现有类型的基础上，通过增加新的方法或者重定义已有方法（下面会讲到，这种方式叫重写）的方式，产生一个新的类型。

继承是面向对象的三个基本特征--封装、继承、多态的其中之一，我们在使用JAVA时编写的每一个类都是在继承，因为在JAVA语言中，``java.lang.Object``类是所有类最根本的基类（或者叫父类、超类），如果我们新定义的一个类没有明确地指定继承自哪个基类，那么Java就会默认为它是继承自Object类的。

可以把JAVA中的类分为以下三种： 

> 类：使用class定义且不含有抽象方法的类。

> 抽象类：使用abstract class定义的类，它可以含有，也可以不含有抽象方法。

> 接口：使用interface定义的类。

在这三种类型之间存在下面的继承规律： 

> 类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。

> 抽象类可以继承（extends）类，可以继承（extends）抽象类，可以继承（implements）接口。

> 接口只能继承（extends）接口。

使用继承和组合复用原有的类，都是一种增量式的开发模式，这种方式带来的好处是不需要修改原有的代码，因此不会给原有代码带来新的BUG，也不用因为对原有代码的修改而重新进行测试，这对我们的开发显然是有益的。因此，如果我们是在维护或者改造一个原有的系统或模块，尤其是对它们的了解不是很透彻的时候，就可以选择增量开发的模式，这不仅可以大大提高我们的开发效率，也可以规避由于对原有代码的修改而带来的风险。 

## 多态(Polymorphism) 

继承是多态得以实现的基础。从字面上理解，多态就是一种类型表现出多种状态）。将一个方法调用同这个方法所属的主体（也就是对象或类）关联起来叫做绑定，分前期绑定和后期绑定两种。下面解释一下它们的定义： 

> **前期绑定**：在程序运行之前进行绑定，由编译器和连接程序实现，又叫做静态绑定。比如static方法和final方法，注意，这里也包括private方法，因为它是隐式final的。

> 后期绑定：在运行时根据对象的类型进行绑定，由方法调用机制实现，因此又叫做动态绑定，或者运行时绑定。除了前期绑定外的所有方法都属于后期绑定。

多态就是在后期绑定这种机制上实现的。多态给我们带来的好处是消除了类之间的耦合关系，使程序更容易扩展。

## 重载(overloading)和重写(overriding) 
- 重载和重写都是针对方法的概念，在弄清楚这两个概念之前，我们先来了解一下什么叫方法的**型构**（英文名是signature，有的译作“签名”，虽然它被使用的较为广泛，但是这个翻译不准确的）。
- 型构就是指方法的组成结构，具体包括方法的名称和参数，涵盖参数的数量、类型以及出现的顺序，但是不包括方法的返回值类型，访问权限修饰符，以及abstract、static、final等修饰符。

比如下面两个就是具有相同型构的方法： 

```
public void method(int i, String s) {   
    // do something   
}   
  
public String method(int i, String s) {   
    // do something   
}  
```
而这两个就是具有不同型构的方法： 

```
public void method(int i, String s) {   
    // do something   
}   
  
public void method(String s, int i) {   
    // do something   
}  
```

了解完型构的概念后我们再来看看重载和重写，请看它们的定义： 

> 重写，英文名是overriding，是指在继承情况下，子类中定义了与其基类中方法具有相同型构的新方法，就叫做子类把基类的方法重写了。这是实现多态必须的步骤。

> 重载，英文名是overloading，是指在同一个类中定义了一个以上具有相同名称，但是型构不同的方法。在同一个类中，是不允许定义多于一个的具有相同型构的方法的。

考虑一个问题：构造器可以被重载吗？答案当然是可以的，我们在实际的编程中也经常这么做。

实际上构造器也是一个方法，构造器名就是方法名，构造器参数就是方法参数，而它的返回值就是新创建的类的实例。但是构造器却不可以被子类重写，因为子类无法定义与基类具有相同型构的构造器。

# Linux命令行操作
## find文件查找命令与grep文件内容查找命令

- 在使用linux时，经常需要进行文件查找。其中查找的命令主要有find和grep。两个命令是有区的。
区别：(1)find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 
(2)grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。

### 一.find命令
- 基本格式：find  path expression

1.按照文件名查找

(1)find / -name httpd.conf　　#在根目录下查找文件httpd.conf，表示在整个硬盘查找

(2)find /etc -name httpd.conf　　#在/etc目录下文件httpd.conf

(3)find /etc -name '*srm*'　　#使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件

(4)find . -name 'srm*' 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件

2.按照文件特征查找 　　　
　
(1)find / -amin -10 　　# 查找在系统中最后10分钟访问的文件(access time)

(2)find / -atime -2　　 # 查找在系统中最后48小时访问的文件

(3)find / -empty 　　# 查找在系统中为空的文件或者文件夹

(4)find / -group cat 　　# 查找在系统中属于 group为cat的文件

(5)find / -mmin -5 　　# 查找在系统中最后5分钟里修改过的文件(modify time)

(6)find / -mtime -1 　　#查找在系统中最后24小时里修改过的文件

(7)find / -user fred 　　#查找在系统中属于fred这个用户的文件

(8)find / -size +10000c　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)(9)find / -size -1000k 　　#查找出小于1000KB的文件

3.使用混合查找方式查找文件

- 参数有： ！，-and(-a)，-or(-o)。

(1)find /tmp -size +10000c -and -mtime +2 　　#在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件

(2)find / -user fred -or -user george 　　#在/目录下查找用户是fred或者george的文件文件

(3)find /tmp ! -user panda　　#在/tmp目录中查找所有不属于panda用户的文件

### 二、grep命令

- 基本格式：find  expression

1.主要参数

　　　　[options]主要参数：
```
－c：只输出匹配行的计数。
－i：不区分大小写
－h：查询多文件时不显示文件名。
－l：查询多文件时只输出包含匹配字符的文件名。
－n：显示匹配行及行号。
－s：不显示不存在或无匹配文本的错误信息。
－v：显示不包含匹配文本的所有行。
```
pattern正则表达式主要参数：
```
\： 忽略正则表达式中特殊字符的原有含义。
^：匹配正则表达式的开始行。
$: 匹配正则表达式的结束行。
\<：从匹配正则表达 式的行开始。
\>：到匹配正则表达式的行结束。
[ ]：单个字符，如[A]即A符合要求 。
[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
.：所有的单个字符。
* ：有字符，长度可以为0。
```

2.实例　 

(1)grep 'test' d*　　#显示所有以d开头的文件中包含 test的行

(2)grep ‘test’ aa bb cc 　　 #显示在aa，bb，cc文件中包含test的行

(3)grep ‘[a-z]\{5\}’ aa 　　#显示所有包含每行字符串至少有5个连续小写字符的字符串的行

(4)grep magic /usr/src　　#显示/usr/src目录下的文件(不含子目录)包含magic的行

(5)grep -r magic /usr/src　　#显示/usr/src目录下的文件(包含子目录)包含magic的行

(6)grep -w pattern files 只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)